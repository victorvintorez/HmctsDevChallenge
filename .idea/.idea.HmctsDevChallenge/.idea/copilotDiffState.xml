<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/HmctsDevChallenge.Backend.Test/Integration/Dependencies/DisappearingTaskFactory.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HmctsDevChallenge.Backend.Test/Integration/Dependencies/DisappearingTaskFactory.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using HmctsDevChallenge.Backend.Database;&#10;using Microsoft.AspNetCore.Mvc.Testing;&#10;using Microsoft.EntityFrameworkCore;&#10;using Microsoft.Extensions.DependencyInjection.Extensions;&#10;&#10;namespace HmctsDevChallenge.Backend.Test.Integration.Dependencies;&#10;&#10;/// &lt;summary&gt;&#10;/// A custom test factory that simulates a scenario where a task is saved but cannot be retrieved.&#10;/// This tests the edge case where the database save succeeds but the subsequent query fails.&#10;/// &lt;/summary&gt;&#10;public class DisappearingTaskFactory : WebApplicationFactory&lt;Program&gt;&#10;{&#10;    protected override void ConfigureWebHost(IWebHostBuilder builder)&#10;    {&#10;        builder.UseEnvironment(&quot;Test&quot;);&#10;        &#10;        builder.ConfigureServices(services =&gt;&#10;        {&#10;            services.RemoveAll&lt;DbContextOptions&lt;HmctsDbContext&gt;&gt;();&#10;            &#10;            services.AddDbContext&lt;HmctsDbContext&gt;(options =&gt;&#10;            {&#10;                options.UseInMemoryDatabase(&quot;DisappearingDb&quot;);&#10;            });&#10;            &#10;            // Replace the HmctsDbContext with a custom version that &quot;loses&quot; tasks after save&#10;            services.RemoveAll&lt;HmctsDbContext&gt;();&#10;            services.AddScoped&lt;HmctsDbContext, DisappearingTaskDbContext&gt;();&#10;        });&#10;        &#10;        builder.ConfigureServices(services =&gt;&#10;        {&#10;            var serviceProvider = services.BuildServiceProvider();&#10;            using var scope = serviceProvider.CreateScope();&#10;            var db = scope.ServiceProvider.GetRequiredService&lt;HmctsDbContext&gt;();&#10;            &#10;            db.Database.EnsureCreated();&#10;        });&#10;    }&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// A custom DbContext that saves tasks but makes them unavailable for queries,&#10;/// simulating a race condition or data inconsistency scenario where a task cannot be found after being saved.&#10;/// &lt;/summary&gt;&#10;public class DisappearingTaskDbContext : HmctsDbContext&#10;{&#10;    public DisappearingTaskDbContext(DbContextOptions&lt;HmctsDbContext&gt; options) : base(options)&#10;    {&#10;    }&#10;&#10;    public override async Task&lt;int&gt; SaveChangesAsync(CancellationToken cancellationToken = default)&#10;    {&#10;        var result = await base.SaveChangesAsync(cancellationToken);&#10;        &#10;        // After saving, clear all tasks from the context to simulate them disappearing&#10;        var tasks = Tasks.Local.ToList();&#10;        foreach (var task in tasks)&#10;        {&#10;            Tasks.Remove(task);&#10;        }&#10;        &#10;        // Clear the in-memory database&#10;        await Tasks.ExecuteDeleteAsync(cancellationToken);&#10;        &#10;        return result;&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/HmctsDevChallenge.Backend.Test/Integration/Dependencies/FailingDbContextFactory.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HmctsDevChallenge.Backend.Test/Integration/Dependencies/FailingDbContextFactory.cs" />
              <option name="updatedContent" value="using HmctsDevChallenge.Backend.Database;&#10;using Microsoft.AspNetCore.Mvc.Testing;&#10;using Microsoft.EntityFrameworkCore;&#10;using Microsoft.Extensions.DependencyInjection.Extensions;&#10;&#10;namespace HmctsDevChallenge.Backend.Test.Integration.Dependencies;&#10;&#10;/// &lt;summary&gt;&#10;/// A custom test factory that configures the database to fail on save operations.&#10;/// This is used to test error handling when database operations fail.&#10;/// &lt;/summary&gt;&#10;public class FailingDbContextFactory : WebApplicationFactory&lt;Program&gt;&#10;{&#10;    protected override void ConfigureWebHost(IWebHostBuilder builder)&#10;    {&#10;        builder.UseEnvironment(&quot;Test&quot;);&#10;        &#10;        builder.ConfigureServices(services =&gt;&#10;        {&#10;            services.RemoveAll&lt;DbContextOptions&lt;HmctsDbContext&gt;&gt;();&#10;            &#10;            services.AddDbContext&lt;HmctsDbContext&gt;(options =&gt;&#10;            {&#10;                // Use a database name that will cause issues or set it up to fail&#10;                options.UseInMemoryDatabase(&quot;FailingDb&quot;);&#10;            });&#10;            &#10;            // Replace the HmctsDbContext with a custom failing version&#10;            services.RemoveAll&lt;HmctsDbContext&gt;();&#10;            services.AddScoped&lt;HmctsDbContext, FailingHmctsDbContext&gt;();&#10;        });&#10;        &#10;        builder.ConfigureServices(services =&gt;&#10;        {&#10;            var serviceProvider = services.BuildServiceProvider();&#10;            using var scope = serviceProvider.CreateScope();&#10;            var db = scope.ServiceProvider.GetRequiredService&lt;HmctsDbContext&gt;();&#10;            &#10;            db.Database.EnsureCreated();&#10;        });&#10;    }&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// A custom DbContext that throws DbUpdateException on SaveChangesAsync to simulate database failures.&#10;/// &lt;/summary&gt;&#10;public class FailingHmctsDbContext : HmctsDbContext&#10;{&#10;    public FailingHmctsDbContext(DbContextOptions&lt;HmctsDbContext&gt; options) : base(options)&#10;    {&#10;    }&#10;&#10;    public override Task&lt;int&gt; SaveChangesAsync(CancellationToken cancellationToken = default)&#10;    {&#10;        throw new DbUpdateException(&quot;Simulated database save failure&quot;);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/HmctsDevChallenge.Backend.Test/Integration/TestWebApplicationFactory.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HmctsDevChallenge.Backend.Test/Integration/TestWebApplicationFactory.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using HmctsDevChallenge.Backend.Database;&#10;using Microsoft.AspNetCore.Hosting;&#10;using Microsoft.AspNetCore.Mvc.Testing;&#10;using Microsoft.EntityFrameworkCore;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Microsoft.Extensions.DependencyInjection.Extensions;&#10;&#10;namespace HmctsDevChallenge.Backend.Test.Integration;&#10;&#10;/// &lt;summary&gt;&#10;/// Custom WebApplicationFactory for integration testing.&#10;/// &#10;/// This class configures a test version of the application with:&#10;/// - An in-memory database instead of PostgreSQL&#10;/// - Test environment configuration&#10;/// - Automatic database setup&#10;/// &#10;/// By inheriting from WebApplicationFactory&amp;lt;Program&amp;gt;, we get:&#10;/// - A test HTTP server that hosts our application&#10;/// - The ability to override services (like the database)&#10;/// - Access to the DI container for verification&#10;/// &#10;/// Usage: Pass this as IClassFixture&amp;lt;TestWebApplicationFactory&amp;gt; to test classes&#10;/// &lt;/summary&gt;&#10;public class TestWebApplicationFactory : WebApplicationFactory&lt;Program&gt;&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Configures the test host with test-specific settings.&#10;    /// This method is called before the application starts.&#10;    /// &lt;/summary&gt;&#10;    protected override void ConfigureWebHost(IWebHostBuilder builder)&#10;    {&#10;        // Set the environment to &quot;Test&quot; so Program.cs can skip database migrations&#10;        // This prevents the app from trying to run EF Core migrations on our in-memory database&#10;        builder.UseEnvironment(&quot;Test&quot;);&#10;        &#10;        // Replace the production database with an in-memory database for testing&#10;        builder.ConfigureServices(services =&gt;&#10;        {&#10;            // Remove the existing DbContext registration (which uses PostgreSQL)&#10;            // RemoveAll ensures we remove all variations (DbContext, DbContextPool, etc.)&#10;            services.RemoveAll(typeof(DbContextOptions&lt;HmctsDbContext&gt;));&#10;&#10;            // Add a new DbContext configuration using in-memory database&#10;            // In-memory database benefits:&#10;            // - Fast: No disk I/O or network calls&#10;            // - Isolated: Each test gets a fresh database&#10;            // - Simple: No need for Docker or external database server&#10;            services.AddDbContext&lt;HmctsDbContext&gt;(options =&gt;&#10;            {&#10;                options.UseInMemoryDatabase(&quot;InMemoryTestDb&quot;);&#10;            });&#10;        });&#10;        &#10;        // Initialize the in-memory database&#10;        // This ensures the database is ready before any tests run&#10;        builder.ConfigureServices(services =&gt;&#10;        {&#10;            // Build a temporary service provider to access the DbContext&#10;            var serviceProvider = services.BuildServiceProvider();&#10;            using var scope = serviceProvider.CreateScope();&#10;            var db = scope.ServiceProvider.GetRequiredService&lt;HmctsDbContext&gt;();&#10;            &#10;            // EnsureCreated() creates the database schema without running migrations&#10;            // This is perfect for in-memory databases where migrations don't make sense&#10;            db.Database.EnsureCreated();&#10;        });&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>